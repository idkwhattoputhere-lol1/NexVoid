// NexVoid - Main JavaScript
// Animaciones premium y microinteracciones

class NexVoidApp {
    constructor() {
        this.isLoaded = false;
        this.sounds = {};
        this.init();
    }
    
    init() {
        this.setupLoadingScreen();
        this.setupBackgroundAnimation();
        this.setupScrollAnimations();
        this.setupNavigation();
        this.setupSoundEffects();
        this.setupCustomCursor();
        this.setupParticleSystem();
        this.setupSmoothScrolling();
    }
    
    // Loading Screen Artística
    setupLoadingScreen() {
        const loadingScreen = document.getElementById('loadingScreen');
        const loadingLogo = document.getElementById('loadingLogo');
        
        // Animar logo al cargar
        anime({
            targets: loadingLogo,
            opacity: [0, 1],
            scale: [0.8, 1],
            duration: 2000,
            easing: 'easeOutElastic(1, .8)',
            complete: () => {
                // Esperar un momento antes de ocultar
                setTimeout(() => {
                    this.hideLoadingScreen();
                }, 1500);
            }
        });
        
        // Animar los anillos de carga
        anime({
            targets: '.loading-ring',
            rotate: 360,
            duration: 4000,
            loop: true,
            easing: 'linear'
        });
    }
    
    hideLoadingScreen() {
        const loadingScreen = document.getElementById('loadingScreen');
        
        anime({
            targets: loadingScreen,
            opacity: [1, 0],
            duration: 1000,
            easing: 'easeOutQuart',
            complete: () => {
                loadingScreen.style.display = 'none';
                this.isLoaded = true;
                this.startEntranceAnimations();
            }
        });
    }
    
    // Animaciones de entrada
    startEntranceAnimations() {
        // Hero title
        anime({
            targets: '.hero-title',
            opacity: [0, 1],
            translateY: [50, 0],
            duration: 1500,
            delay: 300,
            easing: 'easeOutExpo'
        });
        
        // Stagger para otros elementos del hero
        anime({
            targets: '#hero .section',
            opacity: [0, 1],
            translateY: [30, 0],
            duration: 1200,
            delay: anime.stagger(200, {start: 600}),
            easing: 'easeOutExpo'
        });
    }
    
    // Sistema de partículas de fondo
    setupParticleSystem() {
        const bgAnimation = document.getElementById('bgAnimation');
        const particleCount = 50;
        
        for (let i = 0; i < particleCount; i++) {
            const particle = document.createElement('div');
            particle.className = 'particle';
            particle.style.left = Math.random() * 100 + '%';
            particle.style.top = Math.random() * 100 + '%';
            bgAnimation.appendChild(particle);
            
            // Animar partículas
            anime({
                targets: particle,
                translateX: () => anime.random(-200, 200),
                translateY: () => anime.random(-200, 200),
                scale: [0, 1, 0],
                opacity: [0, 0.7, 0],
                duration: () => anime.random(8000, 15000),
                loop: true,
                delay: () => anime.random(0, 5000),
                easing: 'easeInOutSine'
            });
        }
        
        // Conectar partículas cercanas con líneas
        this.setupParticleConnections();
    }
    
    setupParticleConnections() {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        canvas.style.position = 'absolute';
        canvas.style.top = '0';
        canvas.style.left = '0';
        canvas.style.width = '100%';
        canvas.style.height = '100%';
        canvas.style.pointerEvents = 'none';
        canvas.style.opacity = '0.1';
        
        const bgAnimation = document.getElementById('bgAnimation');
        bgAnimation.appendChild(canvas);
        
        const resizeCanvas = () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        };
        
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        const particles = Array.from(document.querySelectorAll('.particle'));
        
        const drawConnections = () => {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.strokeStyle = '#3CF2FF';
            ctx.lineWidth = 1;
            
            for (let i = 0; i < particles.length; i++) {
                for (let j = i + 1; j < particles.length; j++) {
                    const p1 = particles[i];
                    const p2 = particles[j];
                    
                    const rect1 = p1.getBoundingClientRect();
                    const rect2 = p2.getBoundingClientRect();
                    
                    const dx = rect1.left - rect2.left;
                    const dy = rect1.top - rect2.top;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < 150) {
                        ctx.globalAlpha = (150 - distance) / 150 * 0.3;
                        ctx.beginPath();
                        ctx.moveTo(rect1.left + rect1.width / 2, rect1.top + rect1.height / 2);
                        ctx.lineTo(rect2.left + rect2.width / 2, rect2.top + rect2.height / 2);
                        ctx.stroke();
                    }
                }
            }
            
            requestAnimationFrame(drawConnections);
        };
        
        drawConnections();
    }
    
    // Animaciones de scroll con GSAP
    setupScrollAnimations() {
        // Esperar a que GSAP esté disponible
        if (typeof gsap !== 'undefined' && typeof ScrollTrigger !== 'undefined') {
            gsap.registerPlugin(ScrollTrigger);
            
            // Animar secciones al entrar
            gsap.utils.toArray('.section').forEach((section, index) => {
                gsap.fromTo(section, 
                    {
                        opacity: 0,
                        y: 50,
                        filter: 'blur(10px)'
                    },
                    {
                        opacity: 1,
                        y: 0,
                        filter: 'blur(0px)',
                        duration: 1.2,
                        ease: 'cubic-bezier(0.16, 1, 0.3, 1)',
                        scrollTrigger: {
                            trigger: section,
                            start: 'top 95%',
                            end: 'bottom 5%',
                            toggleActions: 'play none none reverse'
                        }
                    }
                );
            });
            
            // Parallax suave para el hero
            gsap.to('#hero img', {
                yPercent: -50,
                ease: 'none',
                scrollTrigger: {
                    trigger: '#hero',
                    start: 'top bottom',
                    end: 'bottom top',
                    scrub: true
                }
            });
            
            // Animar feature cards con stagger
            gsap.fromTo('.feature-card', 
                {
                    opacity: 0,
                    y: 40,
                    scale: 0.95
                },
                {
                    opacity: 1,
                    y: 0,
                    scale: 1,
                    duration: 0.8,
                    stagger: 0.2,
                    ease: 'cubic-bezier(0.16, 1, 0.3, 1)',
                    scrollTrigger: {
                        trigger: '.feature-grid',
                        start: 'top 95%'
                    }
                }
            );
            
            // Timeline para changelog
            gsap.fromTo('.changelog-item', 
                {
                    opacity: 0,
                    x: -50
                },
                {
                    opacity: 1,
                    x: 0,
                    duration: 0.8,
                    stagger: 0.3,
                    ease: 'cubic-bezier(0.16, 1, 0.3, 1)',
                    scrollTrigger: {
                        trigger: '#changelog',
                        start: 'top 95%'
                    }
                }
            );
        }
    }
    
    // Navegación suave
    setupNavigation() {
        const navLinks = document.querySelectorAll('a[href^="#"]');
        
        navLinks.forEach(link => {
            link.addEventListener('click', (e) => {
                e.preventDefault();
                const targetId = link.getAttribute('href');
                const targetElement = document.querySelector(targetId);
                
                if (targetElement) {
                    const offsetTop = targetElement.offsetTop - 80; // Ajustar por navbar
                    
                    anime({
                        targets: document.documentElement,
                        scrollTop: offsetTop,
                        duration: 1500,
                        easing: 'cubic-bezier(0.16, 1, 0.3, 1)'
                    });
                }
            });
        });
        
        // Navbar glass effect on scroll
        let lastScrollY = window.scrollY;
        const navbar = document.querySelector('nav');
        
        window.addEventListener('scroll', () => {
            const currentScrollY = window.scrollY;
            
            if (currentScrollY > 100) {
                navbar.style.background = 'rgba(11, 19, 36, 0.9)';
                navbar.style.backdropFilter = 'blur(30px)';
            } else {
                navbar.style.background = 'var(--glass-bg)';
                navbar.style.backdropFilter = 'blur(20px)';
            }
            
            lastScrollY = currentScrollY;
        });
    }
    
    // Efectos de sonido
    setupSoundEffects() {
        // Crear contexto de audio
        this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        // Generar sonidos procedimentalmente
        this.createClickSound();
        this.createHoverSound();
    }
    
    createClickSound() {
        // Crear un sonido suave de click
        const duration = 0.1;
        const sampleRate = this.audioContext.sampleRate;
        const buffer = this.audioContext.createBuffer(1, duration * sampleRate, sampleRate);
        const data = buffer.getChannelData(0);
        
        for (let i = 0; i < data.length; i++) {
            const t = i / sampleRate;
            data[i] = Math.sin(2 * Math.PI * 800 * t) * Math.exp(-t * 10) * 0.1;
        }
        
        this.sounds.click = buffer;
    }
    
    createHoverSound() {
        // Crear un sonido sutil de hover
        const duration = 0.15;
        const sampleRate = this.audioContext.sampleRate;
        const buffer = this.audioContext.createBuffer(1, duration * sampleRate, sampleRate);
        const data = buffer.getChannelData(0);
        
        for (let i = 0; i < data.length; i++) {
            const t = i / sampleRate;
            data[i] = Math.sin(2 * Math.PI * 600 * t) * Math.exp(-t * 8) * 0.05;
        }
        
        this.sounds.hover = buffer;
    }
    
    playSound(soundName) {
        if (!this.audioContext || !this.sounds[soundName]) return;
        
        const source = this.audioContext.createBufferSource();
        const gainNode = this.audioContext.createGain();
        
        source.buffer = this.sounds[soundName];
        source.connect(gainNode);
        gainNode.connect(this.audioContext.destination);
        
        gainNode.gain.setValueAtTime(0.3, this.audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.1);
        
        source.start();
    }
    
    // Cursor personalizado
    setupCustomCursor() {
        const cursor = document.createElement('div');
        cursor.className = 'custom-cursor';
        cursor.style.cssText = `
            position: fixed;
            width: 20px;
            height: 20px;
            border: 2px solid var(--cian-neon);
            border-radius: 50%;
            pointer-events: none;
            z-index: 9998;
            transition: transform 0.1s ease;
            opacity: 0.7;
        `;
        
        document.body.appendChild(cursor);
        
        let mouseX = 0;
        let mouseY = 0;
        let cursorX = 0;
        let cursorY = 0;
        
        document.addEventListener('mousemove', (e) => {
            mouseX = e.clientX;
            mouseY = e.clientY;
        });
        
        const updateCursor = () => {
            cursorX += (mouseX - cursorX) * 0.1;
            cursorY += (mouseY - cursorY) * 0.1;
            
            cursor.style.left = cursorX - 10 + 'px';
            cursor.style.top = cursorY - 10 + 'px';
            
            requestAnimationFrame(updateCursor);
        };
        
        updateCursor();
        
        // Efecto de hover en elementos interactivos
        const interactiveElements = document.querySelectorAll('a, button, .feature-card');
        
        interactiveElements.forEach(element => {
            element.addEventListener('mouseenter', () => {
                cursor.style.transform = 'scale(1.5)';
                cursor.style.background = 'rgba(60, 242, 255, 0.2)';
            });
            
            element.addEventListener('mouseleave', () => {
                cursor.style.transform = 'scale(1)';
                cursor.style.background = 'transparent';
            });
        });
    }
    
    // Scroll suave
    setupSmoothScrolling() {
        // Prevenir scroll momentum en iOS
        let ticking = false;
        
        const updateScroll = () => {
            ticking = false;
        };
        
        const requestScrollUpdate = () => {
            if (!ticking) {
                requestAnimationFrame(updateScroll);
                ticking = true;
            }
        };
        
        window.addEventListener('scroll', requestScrollUpdate);
    }
    
    // Animación de fondo
    setupBackgroundAnimation() {
        // Crear gradiente animado de fondo
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        canvas.style.position = 'fixed';
        canvas.style.top = '0';
        canvas.style.left = '0';
        canvas.style.width = '100%';
        canvas.style.height = '100%';
        canvas.style.zIndex = '-2';
        canvas.style.opacity = '0.3';
        
        document.body.appendChild(canvas);
        
        const resizeCanvas = () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        };
        
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        let time = 0;
        
        const animateBackground = () => {
            const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
            
            const hue1 = (time * 0.01) % 360;
            const hue2 = (time * 0.01 + 60) % 360;
            
            gradient.addColorStop(0, `hsla(${hue1}, 70%, 20%, 0.1)`);
            gradient.addColorStop(1, `hsla(${hue2}, 70%, 20%, 0.1)`);
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            time++;
            requestAnimationFrame(animateBackground);
        };
        
        animateBackground();
    }
}

// Funciones globales para eventos
function playClickSound() {
    if (window.nexVoidApp) {
        window.nexVoidApp.playSound('click');
    }
}

function playHoverSound() {
    if (window.nexVoidApp) {
        window.nexVoidApp.playSound('hover');
    }
}

// Inicializar cuando el DOM esté listo
document.addEventListener('DOMContentLoaded', () => {
    window.nexVoidApp = new NexVoidApp();
    
    // Añadir eventos de hover a todos los botones
    const buttons = document.querySelectorAll('a, button');
    buttons.forEach(button => {
        button.addEventListener('mouseenter', playHoverSound);
    });
    
    // Prevenir el menú contextual en el cursor personalizado
    document.addEventListener('contextmenu', (e) => {
        e.preventDefault();
    });
    
    // Añadir efecto de glitch ocasional al logo
    const logo = document.querySelector('img[alt="NexVoid"]');
    if (logo) {
        setInterval(() => {
            if (Math.random() < 0.1) { // 10% de probabilidad
                anime({
                    targets: logo,
                    translateX: [0, 2, -2, 0],
                    duration: 100,
                    easing: 'easeInOutQuad'
                });
            }
        }, 3000);
    }
    
    // Efecto de respiración en el botón principal
    const primaryButtons = document.querySelectorAll('.btn-primary');
    primaryButtons.forEach(button => {
        anime({
            targets: button,
            scale: [1, 1.02, 1],
            duration: 3000,
            loop: true,
            easing: 'easeInOutSine'
        });
    });
});

// Preloader para imágenes
window.addEventListener('load', () => {
    const images = document.querySelectorAll('img');
    let loadedImages = 0;
    
    images.forEach(img => {
        if (img.complete) {
            loadedImages++;
        } else {
            img.addEventListener('load', () => {
                loadedImages++;
                if (loadedImages === images.length) {
                    // Todas las imágenes cargadas
                    document.body.classList.add('images-loaded');
                }
            });
        }
    });
    
    if (loadedImages === images.length) {
        document.body.classList.add('images-loaded');
    }
});

// Optimización de rendimiento
let ticking = false;

function updateAnimations() {
    // Actualizar animaciones que dependen del scroll
    ticking = false;
}

window.addEventListener('scroll', () => {
    if (!ticking) {
        requestAnimationFrame(updateAnimations);
        ticking = true;
    }
});

// Detección de preferencias del usuario
if (window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
    // Reducir animaciones si el usuario lo prefiere
    document.documentElement.style.setProperty('--animation-duration', '0.01s');
}
